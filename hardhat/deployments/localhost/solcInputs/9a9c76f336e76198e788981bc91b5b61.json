{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/DAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\n\r\nerror ParentContract__NotOwnerOfToken();\r\n\r\n/// @title DAO\r\n/// @author Bram Mathijssen\r\n/// @notice My DAO\r\ncontract DAO {\r\n    /* Type declarations */\r\n    using Counters for Counters.Counter;\r\n\r\n    enum Role {\r\n        USER,\r\n        ADMIN\r\n    }\r\n\r\n    enum Duration {\r\n        DAY,\r\n        WEEK,\r\n        MONTH\r\n    }\r\n\r\n    /* State Variables */\r\n    Counters.Counter private _proposalIds;\r\n    Counters.Counter private _memberIds;\r\n    address private immutable i_owner;\r\n    bytes32 private constant USER = keccak256(abi.encodePacked(\"USER\"));\r\n    bytes32 private constant ADMIN = keccak256(abi.encodePacked(\"ADMIN\"));\r\n\r\n    mapping(address => Member) public members;\r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    address[] private _membersList;\r\n\r\n    /* Structs */\r\n    struct Member {\r\n        // uint256 id;\r\n        address memberAddress;\r\n        bool valid; // checks if member has been initialised in mapping\r\n        bytes32 name;\r\n        uint256 memberSince;\r\n        mapping(bytes32 => bool) role; // mapping gives ability to hold multiple roles\r\n    }\r\n\r\n    struct Proposal {\r\n        uint256 id;\r\n        string title;\r\n        address creator;\r\n        bool valid;\r\n        bool active;\r\n        string description;\r\n        uint32 startDate;\r\n        uint32 endDate;\r\n        uint32 upVotes;\r\n        uint32 downVotes;\r\n        int32 voteCount;\r\n        address[] voters;\r\n    }\r\n\r\n    /* Events */\r\n    event MemberAdded(address indexed memberAddress, bytes32 name, Role role);\r\n    event ProposalCreated(\r\n        uint256 indexed proposalCount,\r\n        string description,\r\n        Duration duration\r\n    );\r\n    event Voted(\r\n        uint256 indexed proposalNumber,\r\n        bool upVote,\r\n        address voterAddress\r\n    );\r\n\r\n    /* Modifiers */\r\n    modifier hasRole(bytes32 _role) {\r\n        bool authorized;\r\n\r\n        if (_role == USER) {\r\n            members[msg.sender].role[ADMIN] || members[msg.sender].role[USER]\r\n                ? authorized = true\r\n                : authorized = false;\r\n        }\r\n        if (_role == ADMIN) {\r\n            members[msg.sender].role[ADMIN]\r\n                ? authorized = true\r\n                : authorized = false;\r\n        }\r\n\r\n        require(authorized == true, \"don't have correct role\");\r\n        _;\r\n    }\r\n\r\n    /* Constructor */\r\n    constructor(bytes32 _name) {\r\n        i_owner = msg.sender;\r\n\r\n        // load struct in storage before assigning values since we are using a mapping inside struct\r\n        Member storage member = members[msg.sender];\r\n        member.valid = true;\r\n        member.name = _name;\r\n        member.memberSince = block.timestamp;\r\n        member.role[ADMIN] = true;\r\n    }\r\n\r\n    /* Functions */\r\n\r\n    /* external Functions */\r\n    function addMember(\r\n        address _address,\r\n        bytes32 _name,\r\n        Role _role\r\n    ) external hasRole(ADMIN) {\r\n        require(_address != address(0), \"address can't be 0\");\r\n        require(_name != bytes32(0), \"name can't be 0\");\r\n        require(members[_address].valid == false, \"member already exists\");\r\n\r\n        Member storage member = members[_address];\r\n        member.memberAddress = _address;\r\n        member.valid = true;\r\n        member.name = _name;\r\n        member.memberSince = block.timestamp;\r\n        member.role[_getRole(_role)] = true;\r\n\r\n        _membersList.push(_address);\r\n\r\n        emit MemberAdded(_address, _name, _role);\r\n    }\r\n\r\n    // todo: remove member\r\n\r\n    function createProposal(\r\n        string memory _title,\r\n        string memory _description,\r\n        Duration _duration\r\n    ) external hasRole(USER) {\r\n        require(bytes(_description).length > 10, \"need atleast 10 characters\");\r\n        _proposalIds.increment();\r\n        uint256 proposalId = _proposalIds.current();\r\n        proposals[proposalId] = Proposal({\r\n            id: proposalId,\r\n            title: _title,\r\n            creator: msg.sender,\r\n            valid: true,\r\n            description: _description,\r\n            startDate: uint32(block.timestamp),\r\n            endDate: uint32(_getTimestampByDuration(_duration)),\r\n            active: true,\r\n            voteCount: 0,\r\n            upVotes: 0,\r\n            downVotes: 0,\r\n            voters: new address[](0)\r\n        });\r\n        emit ProposalCreated(proposalId, _description, _duration);\r\n    }\r\n\r\n    // function vote(uint256 _proposalNumber, bool upVote) external hasRole(USER) {\r\n    //     Proposal storage proposal = proposals[_proposalNumber];\r\n    //     require(proposal.valid == true, \"proposal not valid\");\r\n    //     require(proposal.active == true, \"proposal not active\");\r\n    //     require(block.timestamp < proposal.endDate, \"proposal ended\");\r\n    //     require(\r\n    //         block.timestamp >= proposal.startDate,\r\n    //         \"proposal hasn't started\"\r\n    //     );\r\n    //     if (upVote) {\r\n    //         proposal.voteCount++;\r\n    //     } else {\r\n    //         proposals[_proposalNumber].voteCount--;\r\n    //     }\r\n    //     emit Voted(_proposalNumber, upVote, msg.sender);\r\n    // }\r\n\r\n    function vote(uint256 _proposalNumber, bool _vote) external hasRole(USER) {\r\n        Proposal storage proposal = proposals[_proposalNumber];\r\n        require(proposal.valid == true, \"proposal not valid\");\r\n        require(proposal.active == true, \"proposal not active\");\r\n        require(block.timestamp < proposal.endDate, \"proposal ended\");\r\n        require(\r\n            block.timestamp >= proposal.startDate,\r\n            \"proposal hasn't started\"\r\n        );\r\n        require(\r\n            _checkVoted(_proposalNumber, msg.sender) == false,\r\n            \"already voted\"\r\n        );\r\n        if (_vote) {\r\n            proposal.upVotes++;\r\n        } else {\r\n            proposal.downVotes++;\r\n        }\r\n        proposal.voters.push(msg.sender);\r\n        proposal.voteCount++;\r\n        emit Voted(_proposalNumber, _vote, msg.sender);\r\n    }\r\n\r\n    function getAllProposals() external view returns (Proposal[] memory) {\r\n        uint256 proposalId = _proposalIds.current();\r\n\r\n        Proposal[] memory proposalsList = new Proposal[](proposalId);\r\n        for (uint256 i = 0; i < proposalId; i++) {\r\n            uint256 currentId = i + 1;\r\n            Proposal storage currentItem = proposals[currentId];\r\n            proposalsList[i] = currentItem;\r\n        }\r\n        return proposalsList;\r\n    }\r\n\r\n    function getMembersList() external view returns (address[] memory) {\r\n        return _membersList;\r\n    }\r\n\r\n    // getting members from member struct with individual properties\r\n    function getMembers()\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory,\r\n            bool[] memory,\r\n            bytes32[] memory,\r\n            uint256[] memory\r\n        )\r\n    {\r\n        address[] memory addresses = new address[](_membersList.length);\r\n        bool[] memory valid = new bool[](_membersList.length);\r\n        bytes32[] memory names = new bytes32[](_membersList.length);\r\n        uint256[] memory memberSince = new uint256[](_membersList.length);\r\n\r\n        for (uint256 i = 0; i < _membersList.length; i++) {\r\n            address tempAddress = _membersList[i];\r\n            addresses[i] = members[tempAddress].memberAddress;\r\n            valid[i] = members[tempAddress].valid;\r\n            names[i] = members[tempAddress].name;\r\n            memberSince[i] = members[tempAddress].memberSince;\r\n        }\r\n        return (addresses, valid, names, memberSince);\r\n    }\r\n\r\n    // doesnt work\r\n    // function getMembersMapping() external returns (Member[] memory) {\r\n\r\n    // }\r\n\r\n    // gets a individual member\r\n    function getMember(\r\n        address _memberAddress\r\n    ) external view returns (address, bool, bytes32, uint256) {\r\n        Member storage member = members[_memberAddress];\r\n        return (\r\n            member.memberAddress,\r\n            member.valid,\r\n            member.name,\r\n            member.memberSince\r\n        );\r\n    }\r\n\r\n    /* public Functions */\r\n    /* internal Functions */\r\n\r\n    /* private Functions */\r\n    function _getTimestampByDuration(\r\n        Duration _duration\r\n    ) private view returns (uint256) {\r\n        if (_duration == Duration.DAY) {\r\n            return block.timestamp + 1 days;\r\n        }\r\n        if (_duration == Duration.WEEK) {\r\n            return block.timestamp + 1 weeks;\r\n        }\r\n        if (_duration == Duration.MONTH) {\r\n            return block.timestamp + 4 weeks;\r\n        }\r\n    }\r\n\r\n    function _grantRole(\r\n        address _memberAddress,\r\n        Role _role\r\n    ) private hasRole(ADMIN) {\r\n        Member storage member = members[_memberAddress];\r\n        member.role[_getRole(_role)] = true;\r\n    }\r\n\r\n    function _getRole(Role _role) private pure returns (bytes32) {\r\n        if (_role == Role.USER) {\r\n            return USER;\r\n        }\r\n        if (_role == Role.ADMIN) {\r\n            return ADMIN;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function _checkVoted(\r\n        uint _proposalNumber,\r\n        address _voterAddress\r\n    ) internal view returns (bool) {\r\n        Proposal memory proposal = proposals[_proposalNumber];\r\n        address[] memory voters = proposal.voters;\r\n        for (uint256 i = 0; i < voters.length; i++) {\r\n            if (voters[i] == _voterAddress) return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}