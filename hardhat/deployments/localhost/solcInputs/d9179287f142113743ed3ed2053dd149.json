{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/DAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\n\r\n/// @title Dapper.dao\r\n/// @author Bram Mathijssen\r\n/// @notice A contract to manage proposals which can be voted on by members which are registered by others\r\ncontract DAO {\r\n    /* Type declarations */\r\n    using Counters for Counters.Counter;\r\n\r\n    /// @notice Enum to declare the role for members\r\n    enum Role {\r\n        USER,\r\n        ADMIN\r\n    }\r\n\r\n    /// @notice Enum to hold the durations for a proposal\r\n    enum Duration {\r\n        DAY,\r\n        WEEK,\r\n        MONTH\r\n    }\r\n\r\n    /* State Variables */\r\n    Counters.Counter private _proposalIds;\r\n    Counters.Counter private _memberIds;\r\n    address private immutable i_owner;\r\n    bytes32 private constant USER = keccak256(abi.encodePacked(\"USER\"));\r\n    bytes32 private constant ADMIN = keccak256(abi.encodePacked(\"ADMIN\"));\r\n\r\n    /// @notice Associative array to get members from mapping\r\n    address[] private _membersList;\r\n\r\n    /* Mappings */\r\n    /// @notice Member address to member struct\r\n    mapping(address => Member) public members;\r\n\r\n    /// @notice _proposalId to proposal struct\r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    /* Structs */\r\n    /**\r\n    @param memberAddress Address of the member.\r\n    @param valid Boolean to check if instance of struct has been created\r\n    @param name Name of member stored in bytes32\r\n    @param memberSince Timestamp of when member has been added\r\n    @param role Mapping which holds roles of member\r\n    */\r\n    struct Member {\r\n        address memberAddress;\r\n        bool valid; \r\n        bytes32 name;\r\n        uint256 memberSince;\r\n        mapping(bytes32 => bool) role; \r\n    }\r\n\r\n    /** \r\n    @param id Id of the proposal which corresponds to the _proposalIds counter.\r\n    @param title Title of the proposal.\r\n    @param creator Address of the creator of the proposal.\r\n    @param valid Boolean to check if proposal has been initialised in mapping\r\n    @param active Boolean to check if proposal is currently active for voting\r\n    @param description Description of the proposal\r\n    @param startDate Start date of the proposal, startDate is equal to creation date of the proposal\r\n    @param endDate End Date of the proposal, after this date voting will close\r\n    @param upVotes Holds the amount of upvotes for the proposal\r\n    @param downVotes Holds the amount of downvotes for the proposal\r\n    @param downVotes Holds the amount of downvotes for the proposal\r\n    @param voteCount Holds the total amount of votes for the proposal\r\n    @param voters Holds a list of all the addresses which have voted on the proposal \r\n    */\r\n    struct Proposal {\r\n        uint256 id;\r\n        string title;\r\n        address creator;\r\n        bool valid;\r\n        bool active;\r\n        string description;\r\n        uint32 startDate;\r\n        uint32 endDate;\r\n        uint32 upVotes;\r\n        uint32 downVotes;\r\n        int32 voteCount;\r\n        address[] voters;\r\n    }\r\n\r\n    /* Events */\r\n    event MemberAdded(address indexed memberAddress, bytes32 name, Role role);\r\n    event ProposalCreated(\r\n        uint256 indexed proposalCount,\r\n        string description,\r\n        Duration duration\r\n    );\r\n    event Voted(\r\n        uint256 indexed proposalNumber,\r\n        bool upVote,\r\n        address voterAddress\r\n    );\r\n\r\n    /* Modifiers */\r\n    /** @dev This modifier checks if a member has the required role(s)\r\n     * @param _role either USER or ADMIN role\r\n     */\r\n    modifier hasRole(bytes32 _role) {\r\n        bool authorized;\r\n\r\n        if (_role == USER) {\r\n            members[msg.sender].role[ADMIN] || members[msg.sender].role[USER]\r\n                ? authorized = true\r\n                : authorized = false;\r\n        }\r\n        if (_role == ADMIN) {\r\n            members[msg.sender].role[ADMIN]\r\n                ? authorized = true\r\n                : authorized = false;\r\n        }\r\n        require(authorized == true, \"don't have correct role\");\r\n        _;\r\n    }\r\n\r\n    /* Constructor */\r\n    /** @dev Initialises the one who deploys the contract as the first admin member\r\n     * @param _name name of owner in bytes32\r\n     */\r\n    constructor(bytes32 _name) {\r\n        i_owner = msg.sender;\r\n\r\n        // load struct in storage before assigning values since we are using a mapping inside struct\r\n        Member storage member = members[msg.sender];\r\n        member.valid = true;\r\n        member.name = _name;\r\n        member.memberSince = block.timestamp;\r\n        member.role[ADMIN] = true;\r\n    }\r\n\r\n\r\n    /* External Functions */\r\n    /** @notice Adds a member to the DAO, only Admins can add new members\r\n     * @param _address Address of the member\r\n     * @param _name Member of the name in bytes32\r\n     * @param _role Role of the member (0 = USER, 1 = ADMIN)\r\n     */\r\n    function addMember(\r\n        address _address,\r\n        bytes32 _name,\r\n        Role _role\r\n    ) external hasRole(ADMIN) {\r\n        require(_address != address(0), \"address can't be 0\");\r\n        require(_name != bytes32(0), \"name can't be 0\");\r\n        require(members[_address].valid == false, \"member already exists\");\r\n\r\n        Member storage member = members[_address];\r\n        member.memberAddress = _address;\r\n        member.valid = true;\r\n        member.name = _name;\r\n        member.memberSince = block.timestamp;\r\n        member.role[_getRole(_role)] = true;\r\n\r\n        _membersList.push(_address);\r\n\r\n        emit MemberAdded(_address, _name, _role);\r\n    }\r\n\r\n    /** @notice Creates a new Proposal, either an admin or user can create a proposal.\r\n     * @param _title Title of the proposal\r\n     * @param _description Description of the proposal\r\n     * @param _duration Duration which the proposal will be open from the moment of creation (0 = DAY, 1 = WEEK, 2 = MONTH)\r\n     */\r\n    function createProposal(\r\n        string memory _title,\r\n        string memory _description,\r\n        Duration _duration\r\n    ) external hasRole(USER) {\r\n        require(bytes(_description).length > 10, \"need atleast 10 characters\");\r\n        _proposalIds.increment();\r\n        uint256 proposalId = _proposalIds.current();\r\n        proposals[proposalId] = Proposal({\r\n            id: proposalId,\r\n            title: _title,\r\n            creator: msg.sender,\r\n            valid: true,\r\n            description: _description,\r\n            startDate: uint32(block.timestamp),\r\n            endDate: uint32(_getTimestampByDuration(_duration)),\r\n            active: true,\r\n            voteCount: 0,\r\n            upVotes: 0,\r\n            downVotes: 0,\r\n            voters: new address[](0)\r\n        });\r\n        emit ProposalCreated(proposalId, _description, _duration);\r\n    }\r\n\r\n    /** @notice up or downvote a proposal by id\r\n     * @param _proposalNumber Id of the proposal which will be voted on\r\n     * @param _vote To give a downvote bool should be 0, to give a upvote bool should be 1\r\n     */\r\n    function vote(uint256 _proposalNumber, bool _vote) external hasRole(USER) {\r\n        Proposal storage proposal = proposals[_proposalNumber];\r\n        require(proposal.valid == true, \"proposal not valid\");\r\n        require(proposal.active == true, \"proposal not active\");\r\n        require(block.timestamp < proposal.endDate, \"proposal ended\");\r\n        require(\r\n            block.timestamp >= proposal.startDate,\r\n            \"proposal hasn't started\"\r\n        );\r\n        require(\r\n            _checkVoted(_proposalNumber, msg.sender) == false,\r\n            \"already voted\"\r\n        );\r\n        if (_vote) {\r\n            proposal.upVotes++;\r\n        } else {\r\n            proposal.downVotes++;\r\n        }\r\n        proposal.voters.push(msg.sender);\r\n        proposal.voteCount++;\r\n        emit Voted(_proposalNumber, _vote, msg.sender);\r\n    }\r\n\r\n    /** @notice Gets all the proposals from the proposals mapping\r\n     *  @dev Loops over all the entries from the proposals mapping by using the _proposalIds as associative variable\r\n     */\r\n    function getAllProposals() external view returns (Proposal[] memory) {\r\n        uint256 proposalId = _proposalIds.current();\r\n\r\n        Proposal[] memory proposalsList = new Proposal[](proposalId);\r\n        for (uint256 i = 0; i < proposalId; i++) {\r\n            uint256 currentId = i + 1;\r\n            Proposal storage currentItem = proposals[currentId];\r\n            proposalsList[i] = currentItem;\r\n        }\r\n        return proposalsList;\r\n    }\r\n\r\n    /** @notice Gets all the members from the members mapping\r\n     *  @dev Loops over all the entries from the members mapping by using the addresses from _memberslist as associative array\r\n     *  returning individual properties from members, excluding the role since it's a mapping.\r\n     */\r\n    function getMembers()\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory,\r\n            bool[] memory,\r\n            bytes32[] memory,\r\n            uint256[] memory\r\n        )\r\n    {\r\n        address[] memory addresses = new address[](_membersList.length);\r\n        bool[] memory valid = new bool[](_membersList.length);\r\n        bytes32[] memory names = new bytes32[](_membersList.length);\r\n        uint256[] memory memberSince = new uint256[](_membersList.length);\r\n\r\n        for (uint256 i = 0; i < _membersList.length; i++) {\r\n            address tempAddress = _membersList[i];\r\n            addresses[i] = members[tempAddress].memberAddress;\r\n            valid[i] = members[tempAddress].valid;\r\n            names[i] = members[tempAddress].name;\r\n            memberSince[i] = members[tempAddress].memberSince;\r\n        }\r\n        return (addresses, valid, names, memberSince);\r\n    }\r\n\r\n    /** @notice Helper function to get the timestamp corresponding to the given duration\r\n     * @param _duration Duration which the proposal will be open from the moment of creation (0 = DAY, 1 = WEEK, 2 = MONTH)\r\n     */\r\n    function _getTimestampByDuration(\r\n        Duration _duration\r\n    ) private view returns (uint256) {\r\n        if (_duration == Duration.DAY) {\r\n            return block.timestamp + 1 days;\r\n        }\r\n        if (_duration == Duration.WEEK) {\r\n            return block.timestamp + 1 weeks;\r\n        }\r\n        if (_duration == Duration.MONTH) {\r\n            return block.timestamp + 4 weeks;\r\n        }\r\n        revert(\"Invalid duration\"); // Reverts if no valid duration was found\r\n    }\r\n\r\n    /** @notice Change the role of a member, can only be called by an Admin\r\n     * @param _memberAddress Address of the member which will be granted another role\r\n     * @param _role Enum of the role which will be granted to the member (0 = USER, 1 = ADMIN)\r\n     */\r\n    function _grantRole(\r\n        address _memberAddress,\r\n        Role _role\r\n    ) private hasRole(ADMIN) {\r\n        Member storage member = members[_memberAddress];\r\n        member.role[_getRole(_role)] = true;\r\n    }\r\n\r\n    /** @notice Helper function to get the keccak256 encoded bytes32 of a role\r\n     * @param _role Enum of the role which will be granted to the member (0 = USER, 1 = ADMIN)\r\n     */\r\n    function _getRole(Role _role) private pure returns (bytes32) {\r\n        if (_role == Role.USER) {\r\n            return USER;\r\n        }\r\n        if (_role == Role.ADMIN) {\r\n            return ADMIN;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /** @notice Checks a proposal if a member has already voted on it.\r\n     * @param _proposalNumber Id of the proposal which will be checked for vote\r\n     * @param _voterAddress Address of the member which will be checked for vote\r\n     */\r\n    function _checkVoted(\r\n        uint _proposalNumber,\r\n        address _voterAddress\r\n    ) internal view returns (bool) {\r\n        Proposal memory proposal = proposals[_proposalNumber];\r\n        address[] memory voters = proposal.voters;\r\n        for (uint256 i = 0; i < voters.length; i++) {\r\n            if (voters[i] == _voterAddress) return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}