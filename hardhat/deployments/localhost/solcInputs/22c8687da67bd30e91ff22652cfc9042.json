{
  "language": "Solidity",
  "sources": {
    "contracts/DAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nerror ParentContract__NotOwnerOfToken();\r\n\r\n/// @title DAO\r\n/// @author Bram Mathijssen\r\n/// @notice My DAO\r\ncontract DAO {\r\n    /* Type declarations */\r\n    enum Role {\r\n        USER,\r\n        ADMIN\r\n    }\r\n\r\n    enum Duration {\r\n        DAY,\r\n        WEEK,\r\n        MONTH\r\n    }\r\n\r\n    /* State Variables */\r\n    uint256 private proposalCount;\r\n    address private immutable i_owner;\r\n    bytes32 private constant USER = keccak256(abi.encodePacked(\"USER\"));\r\n    bytes32 private constant ADMIN = keccak256(abi.encodePacked(\"ADMIN\"));\r\n\r\n    mapping(address => Member) public members;\r\n    mapping(uint256 => Proposal) public proposals;\r\n\r\n    /* Structs */\r\n    struct Member {\r\n        bool valid; // checks if member has been initialised in mapping\r\n        bytes32 name;\r\n        uint256 memberSince;\r\n        mapping(bytes32 => bool) role; // mapping gives ability to hold multiple roles\r\n    }\r\n\r\n    struct Proposal {\r\n        bool valid;\r\n        bool active;\r\n        string description;\r\n        uint32 startDate;\r\n        uint32 endDate;\r\n        int32 voteCount;\r\n    }\r\n\r\n    /* Events */\r\n\r\n    /* Modifiers */\r\n    modifier hasRole(bytes32 _role) {\r\n        bool authorized;\r\n\r\n        if (_role == USER) {\r\n            members[msg.sender].role[ADMIN] || members[msg.sender].role[USER]\r\n                ? authorized = true\r\n                : authorized = false;\r\n        }\r\n        if (_role == ADMIN) {\r\n            members[msg.sender].role[ADMIN]\r\n                ? authorized = true\r\n                : authorized = false;\r\n        }\r\n\r\n        require(authorized == true, \"don't have correct role\");\r\n        _;\r\n    }\r\n\r\n    /* Constructor */\r\n    constructor(bytes32 _name) {\r\n        i_owner = msg.sender;\r\n\r\n        // load struct in storage before assigning values since we are using a mapping inside struct\r\n        Member storage member = members[msg.sender];\r\n        member.valid = true;\r\n        member.name = _name;\r\n        member.memberSince = block.timestamp;\r\n        member.role[ADMIN] = true;\r\n    }\r\n\r\n    /* Functions */\r\n    function addMember(\r\n        address _address,\r\n        bytes32 _name,\r\n        Role _role\r\n    ) external hasRole(ADMIN) {\r\n        require(_address != address(0), \"address can't be 0\");\r\n        require(_name != bytes32(0), \"name can't be 0\");\r\n        require(members[_address].valid == false, \"member already exists\");\r\n\r\n        Member storage member = members[_address];\r\n        member.valid = true;\r\n        member.name = _name;\r\n        member.memberSince = block.timestamp;\r\n        member.role[_getRole(_role)] = true;\r\n    }\r\n\r\n    // todo: remove member\r\n\r\n    function createProposal(\r\n        string memory _description,\r\n        Duration _duration\r\n    ) external hasRole(USER) {\r\n        require(bytes(_description).length > 10, \"need atleast 10 characters\");\r\n        proposalCount++;\r\n        proposals[proposalCount] = Proposal({\r\n            valid: true,\r\n            description: _description,\r\n            startDate: uint32(block.timestamp),\r\n            endDate: uint32(_getTimestampByDuration(_duration)),\r\n            active: true,\r\n            voteCount: 0\r\n        });\r\n    }\r\n\r\n    function vote(uint256 _proposalNumber, bool upVote) external hasRole(USER) {\r\n        Proposal storage proposal = proposals[_proposalNumber];\r\n        require(proposal.valid == true, \"proposal not valid\");\r\n        require(proposal.active == true, \"proposal not active\");\r\n        require(block.timestamp < proposal.endDate, \"proposal ended\");\r\n        require(\r\n            block.timestamp >= proposal.startDate,\r\n            \"proposal hasn't started\"\r\n        );\r\n        if (upVote) {\r\n            proposal.voteCount++;\r\n        } else {\r\n            proposals[_proposalNumber].voteCount--;\r\n        }\r\n    }\r\n\r\n    /* external Functions */\r\n    /* public Functions */\r\n    /* internal Functions */\r\n\r\n    /* private Functions */\r\n    function _getTimestampByDuration(\r\n        Duration _duration\r\n    ) private view returns (uint256) {\r\n        if (_duration == Duration.DAY) {\r\n            return block.timestamp + 1 days;\r\n        }\r\n        if (_duration == Duration.WEEK) {\r\n            return block.timestamp + 1 weeks;\r\n        }\r\n        if (_duration == Duration.MONTH) {\r\n            return block.timestamp + 4 weeks;\r\n        }\r\n    }\r\n\r\n    function _grantRole(\r\n        address _memberAddress,\r\n        Role _role\r\n    ) private hasRole(ADMIN) {\r\n        Member storage member = members[_memberAddress];\r\n        member.role[_getRole(_role)] = true;\r\n    }\r\n\r\n    function _getRole(Role _role) private pure returns (bytes32) {\r\n        if (_role == Role.USER) {\r\n            return USER;\r\n        }\r\n        if (_role == Role.ADMIN) {\r\n            return ADMIN;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n"
    },
    "contracts/Lock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            \"Unlock time should be in the future\"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n\n    function withdraw() public {\n        // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal\n        // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp);\n\n        require(block.timestamp >= unlockTime, \"You can't withdraw yet\");\n        require(msg.sender == owner, \"You aren't the owner\");\n\n        emit Withdrawal(address(this).balance, block.timestamp);\n\n        owner.transfer(address(this).balance);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}